#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <sys/wait.h>
#include <ctype.h>
// author :  Santiago Rodriguez : rodriguez.santiago@correounivalles.edu.co
// date last mod: May 7, 2018.

//second func.
void discrimand(char command_args[80], char** reference){
	char *aux;
	int i=0;
	aux = strtok(command_args, " ");
	while(aux != NULL){
		reference[i]=strdup(aux);
		reference[i+1]= NULL;
		aux = strtok(NULL, " ");
		i++;
	}
}

void outToFile(char ** argss){
	char here[3]="./";
	char aux[3]= ">";
	int j=0;
	while(argss[j]!=NULL){

		if(! strcmp(argss[j], aux)){
			close(STDOUT_FILENO);
			open(strcat(here, argss[j+1]), O_CREAT|O_WRONLY|O_TRUNC, S_IRWXU);
			argss[j]= NULL;
		}
		j++;
	}
}

void divArray(char ** arrayToDiv, char** &first, char** &second){	//comprobaded.
	char aux[3]= "|";
	int flag=0;
	int i=0;
	while(arrayToDiv[i] != NULL){
		if(!strcmp(arrayToDiv[i], aux)){
			second = arrayToDiv + i + 1;
			arrayToDiv[i]=NULL;
			first = arrayToDiv;
		}
		i++;

	}
//printf("while 'divArray' ended\n");
//printf("%s\n",first[0]);
//printf("%s\n",second[0]);
}

int existPipe(char** commands){ // comprobaded.
	int j=0;
	char aux[3]="|";
	while(commands[j] != NULL){
		if(!strcmp(commands[j], aux)){
			return 1;
		}
		j++;
	}
	return 0;
}

void piper(char ** arguments){
	
	int fd[2], estado;
	pid_t hijo;
	char** argumento1;
	char** argumento2;
	divArray(arguments, argumento1, argumento2);

	hijo=fork();
	if (hijo==-1) printf("ERROR Creacion de proceso"); 
	else if (hijo==0) {
			   pipe(&fd[0]); // Funcion pipe encargada de crear la tuberia 
			   if (fork()!=0) {
	      				close(fd[0]); // cerramos el lado de lectura del pipe *
	      				close(1);
	      				dup(fd[1]); // STDOUT = extremo de salida del pipe *
	      				close(fd[1]);// cerramos el descriptor de fichero que sobra tras el dup(fd[1])*
	      				execvp(argumento1[0],argumento1);
	      			}
	      			else {
	      				close(fd[1]);//cerramos el lado de lectura del pipe *
	      				close(0);
	      				dup(fd[0]);// STDOUT = extremo de salida del pipe *
	      				close(fd[0]);// cerramos el descriptor de fichero que sobra tras el dup(fd[0])*
	      				execvp(argumento2[0],argumento2);

	      			}
	      		}
	      		else  hijo=wait(&estado);
	      	}






 int main(int argc, char *argv[]){
 	while(1){
 		char command[80];
 		printf("~$");
 		scanf(" %[^\n]s", command);
 		if( ! strcmp(command, "exit")){
 			break;
 		}else{

 			int rc = fork();
				if (rc < 0) {// fork failed; exit
					fprintf(stderr, "fork failed\n");
					exit(1);
				} else if (rc == 0) { // child: redirect standard output to a file // not yet.
					char *myargs[40];
					discrimand(command, myargs);
					outToFile(myargs);
					if(existPipe(myargs)){
						piper(myargs);
						break;
					}else{
						execvp(myargs[0], myargs);  // runs command
						break;
					}
				//strcpy(command, "exit"); // failed try to fix exit trouble generated by non executed command.
				} else {// parent goes down this path (main)
					int wc = wait(NULL);
				}
			}
		}
		return 0;
	}

